import Tesseract from 'tesseract.js';
import sharp from 'sharp';
import { pool } from '../../../config/database.js';
import path from 'path';
import fs from 'fs/promises';
import DocumentClassifier from './documentClassifier.js';
import ImageProcessor from './imageProcessor.js';
import GeometricWordSeparator from './geometricWordSeparator.js';

// ================= üîç SERVICIO PRINCIPAL DE OCR =================

class OCRService {
  constructor() {
    this.classifier = new DocumentClassifier();
    this.geometricSeparator = new GeometricWordSeparator();
    this.tesseractOptions = {
      logger: m => {
        if (m.status === 'recognizing text') {
          const progress = (m.progress * 100).toFixed(1);
          console.log(`üìÑ Tesseract: ${m.status} - ${progress}%`);
        } else {
          console.log(`üìÑ Tesseract: ${m.status} - ${(m.progress * 100).toFixed(1)}%`);
        }
      }
    };

    // Configuraciones optimizadas de Tesseract para mejor reconocimiento
    this.defaultTesseractConfig = {
      tessedit_pageseg_mode: 6, // Asume un solo bloque uniforme de texto
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,;:!?()-"\'√°√©√≠√≥√∫√º√±√Å√â√ç√ì√ö√ú√ë/$',
      preserve_interword_spaces: 1,
      tessedit_do_invert: 0,
      load_system_dawg: 1,
      load_freq_dawg: 1
    };

    // Configuraciones espec√≠ficas para recibos de EUROPIEL - OPTIMIZADO PARA NOMBRES
    this.europielConfig = {
      tessedit_pageseg_mode: 6, // Un bloque uniforme de texto - MEJOR para nombres
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,;:!?()-"\'√°√©√≠√≥√∫√º√±√Å√â√ç√ì√ö√ú√ë/$',
      preserve_interword_spaces: 1,
      tessedit_create_hocr: 1,
      tessedit_create_tsv: 1,
      load_system_dawg: 1,
      load_freq_dawg: 1,
      load_unambig_dawg: 1,
      load_punc_dawg: 1,
      load_number_dawg: 1,
      load_bigram_dawg: 1,
      // üéØ CONFIGURACIONES MEJORADAS PARA NOMBRES REALES
      tessedit_write_images: 0,
      // Diccionario con TODOS los nombres de los recibos reales
      user_words_suffix: 'EUROPIEL LASER CENTER SINERGIA TERESA IRASEMA POMPA MANDUJANO FLOR YANET ISLAS PIMENTEL NICOLE GUADALUPE RODRIGUEZ PE√ëA CYNTHIA VERVER VARGAS ROMERO KARINA ELIZABETH CENTENO ADA YACUNAHIL JUAREZ OTERO ROSA MARIA HERNANDEZ ORTIZ MARIANA CESIN SASTRE ANTICIPO PAQUETE NUEVO TRANSACCION APROBADA',
      user_patterns_suffix: 'Q##-#### \\d{2}/\\d{2}/\\d{4} $#,###.##',
      // üîß MEJORAR DETECCI√ìN DE CARACTERES
      classify_enable_learning: 1,
      classify_enable_adaptive_matcher: 1,
      textord_debug_tabfind: 0,
      // üéØ CONFIGURACI√ìN PARA TEXTO IMPRESO DE BUENA CALIDAD
      textord_straight_baselines: 1,  // Texto bien alineado
      textord_old_baselines: 0,       // Usar nueva detecci√≥n
      wordrec_enable_assoc: 1,
      // üöÄ REDUCIR UMBRALES DE RECHAZO PARA CAPTURAR M√ÅS TEXTO
      tessedit_reject_doc_percent: 100,
      tessedit_reject_block_percent: 100,
      tessedit_reject_row_percent: 100,
      classify_min_certainty_factor: 0.1
    };

    // Patrones espec√≠ficos de EUROPIEL para mejor reconocimiento
    this.europielPatterns = [
      'EUROPIEL',
      'LASER CENTER',
      'Recibo de Pago',
      'Folio:',
      'Fecha:',
      'Recib√≠ de',
      'la cantidad de',
      'por concepto de',
      'Forma de Pago:',
      'TRANSACCION APROBADA',
      'Tarjeta',
      'Autorizaci√≥n',
      'Comercio',
      'ARQC',
      'Firma'
    ];

    // ‚ö° INICIALIZAR FAST MODE POR DEFECTO
    this.configureImageEnhancements({ fastMode: true });
    console.log('‚ö° OCRService inicializado con Fast Mode activado por defecto');
  }

  /**
   * Detectar si es un documento de EUROPIEL mediante an√°lisis r√°pido
   */
  async detectDocumentType(imagePath) {
    try {
      // An√°lisis r√°pido con configuraci√≥n b√°sica
      const quickResult = await Tesseract.recognize(
        imagePath,
        'spa+eng',
        {
          logger: () => {}, // Sin logging para an√°lisis r√°pido
          tessedit_pageseg_mode: 1,
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
        }
      );

      const text = quickResult.data.text.toUpperCase();

      // Verificar patrones de EUROPIEL
      const isEuropiel = this.europielPatterns.some(pattern =>
        text.includes(pattern.toUpperCase())
      );

      console.log(`üîç Tipo de documento detectado: ${isEuropiel ? 'EUROPIEL' : 'GENERAL'}`);

      return {
        type: isEuropiel ? 'europiel' : 'general',
        confidence: isEuropiel ? 0.9 : 0.5
      };
    } catch (error) {
      console.log('‚ö†Ô∏è Error en detecci√≥n r√°pida, usando configuraci√≥n general');
      return { type: 'general', confidence: 0.3 };
    }
  }

  /**
   * Procesar imagen con OCR
   */
  async processImage(imagePath, options = {}) {
    try {
      console.log(`üîç Iniciando procesamiento OCR: ${imagePath}`);
      const startTime = Date.now();

      // 1. Detectar tipo de documento
      const docType = await this.detectDocumentType(imagePath);

      // 2. Preprocesar imagen para mejorar OCR
      const preprocessResult = await this.preprocessImage(imagePath, docType.type);
      const preprocessedPath = typeof preprocessResult === 'string' ? preprocessResult : preprocessResult.path;

      // 3. Intentar OCR con m√∫ltiples configuraciones para mejor precisi√≥n
      let bestResult = null;
      let bestConfidence = 0;
      let bestConfigName = '';

      const configurations = [
        {
          name: 'EUROPIEL_OPTIMIZED',
          config: docType.type === 'europiel' ? this.europielConfig : this.defaultTesseractConfig,
          language: 'spa+eng'
        },
        {
          name: 'HIGH_ACCURACY',
          config: {
            ...(docType.type === 'europiel' ? this.europielConfig : this.defaultTesseractConfig),
            tessedit_pageseg_mode: 6, // Bloque uniforme de texto
            tessedit_ocr_engine_mode: 1 // Neural network LSTM
          },
          language: 'spa+eng'
        },
        {
          name: 'SPARSE_TEXT_FALLBACK',
          config: {
            tessedit_pageseg_mode: 11, // Texto disperso
            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,;:!?()-"\'√°√©√≠√≥√∫√º√±√Å√â√ç√ì√ö√ú√ë/$Q',
            preserve_interword_spaces: 1
          },
          language: 'spa+eng'
        }
      ];

      console.log(`ÔøΩ Probando ${configurations.length} configuraciones de OCR...`);

      for (const config of configurations) {
        try {
          console.log(`üîß Intentando configuraci√≥n: ${config.name}...`);

          const ocrResult = await Tesseract.recognize(
            preprocessedPath,
            config.language,
            {
              ...this.tesseractOptions,
              ...config.config,
              ...options.tesseractConfig
            }
          );

          const confidence = ocrResult.data.confidence / 100;
          const textLength = ocrResult.data.text.trim().length;

          console.log(`ÔøΩ ${config.name}: Confianza: ${confidence.toFixed(2)}, Texto: ${textLength} chars`);

          // Evaluar calidad del resultado combinando confianza y caracter√≠sticas del texto
          const qualityScore = this.evaluateOCRQuality(ocrResult.data.text, confidence);

          if (qualityScore > bestConfidence && textLength > 0) {
            bestResult = ocrResult;
            bestConfidence = qualityScore;
            bestConfigName = config.name;
            console.log(`‚ú® Nueva mejor configuraci√≥n: ${config.name} (Score: ${qualityScore.toFixed(2)})`);
          }

          // Si obtenemos un resultado excelente, podemos detenernos
          if (qualityScore > 0.85) {
            console.log(`üéâ Resultado excelente obtenido con ${config.name}`);
            break;
          }

        } catch (configError) {
          console.warn(`‚ö†Ô∏è Error en configuraci√≥n ${config.name}:`, configError.message);
          continue;
        }
      }

      if (!bestResult) {
        throw new Error('Todas las configuraciones de OCR fallaron');
      }

      const ocrResult = bestResult;
      console.log(`üèÜ Mejor configuraci√≥n seleccionada: ${bestConfigName} (Score: ${bestConfidence.toFixed(2)})`);

      // 4. Procesar resultados
      const processingTime = Date.now() - startTime;

      // 5. Verificar calidad final del texto extra√≠do
      const extractedText = ocrResult.data.text.trim();
      const finalConfidence = ocrResult.data.confidence / 100;

      console.log(`üìä Texto final extra√≠do: ${extractedText.length} caracteres`);
      console.log(`üìä Confianza final: ${finalConfidence.toFixed(2)} (${finalConfidence >= 0.5 ? 'BUENA' : 'BAJA'})`);

      if (extractedText.length === 0) {
        throw new Error('No se pudo extraer texto del documento con ninguna configuraci√≥n');
      }

      // üéØ AN√ÅLISIS GEOM√âTRICO PARA MEJORAR SEPARACI√ìN DE PALABRAS
      let geometricAnalysis = null;
      let finalText = ocrResult.data.text;

      if (options.useGeometricSeparation !== false) { // Por defecto habilitado
        try {
          console.log(`üéØ Iniciando an√°lisis geom√©trico de espacios...`);

          geometricAnalysis = await this.geometricSeparator.analyzeWithBoundingBoxes(
            preprocessedPath,
            'spa+eng'
          );

          if (geometricAnalysis.spacesAdded > 0) {
            finalText = geometricAnalysis.correctedText;
            console.log(`‚úÖ Separaci√≥n geom√©trica: ${geometricAnalysis.spacesAdded} espacios agregados`);
            console.log(`üìä An√°lisis geom√©trico: ${geometricAnalysis.wordsAnalyzed} palabras analizadas`);
          } else {
            console.log(`‚ÑπÔ∏è Separaci√≥n geom√©trica: No se requirieron espacios adicionales`);
          }

        } catch (geoError) {
          console.warn(`‚ö†Ô∏è Error en an√°lisis geom√©trico (continuando con OCR est√°ndar):`, geoError.message);
        }
      }

      const result = {
        text: finalText, // Usar texto corregido geom√©tricamente si est√° disponible
        originalText: ocrResult.data.text, // Mantener texto original para referencia
        confidence: ocrResult.data.confidence / 100,
        words: ocrResult.data.words,
        lines: ocrResult.data.lines,
        paragraphs: ocrResult.data.paragraphs,
        boundingBoxes: this.extractBoundingBoxes(ocrResult.data),
        geometricAnalysis: geometricAnalysis, // Incluir an√°lisis geom√©trico
        processingTime,
        preprocessedPath,
        bestConfiguration: bestConfigName,
        qualityScore: bestConfidence,
        documentType: docType.type
      };

      // 4. Clasificar el documento autom√°ticamente usando texto corregido
      const classification = this.classifier.classifyDocument(finalText);
      result.classification = classification;

      console.log(`‚úÖ OCR completado en ${processingTime}ms - Confianza: ${result.confidence.toFixed(2)}`);
      console.log(`üè∑Ô∏è Documento clasificado como: ${classification.type} (${classification.confidence.toFixed(2)})`);

      if (geometricAnalysis && geometricAnalysis.spacesAdded > 0) {
        console.log(`üéØ Texto mejorado geom√©tricamente - Espacios agregados: ${geometricAnalysis.spacesAdded}`);
      }
      return { success: true, data: result };

    } catch (error) {
      console.error('‚ùå Error en procesamiento OCR:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Evaluar la calidad de un resultado OCR
   * @param {string} text - Texto extra√≠do por OCR
   * @param {number} confidence - Confianza del OCR (0-1)
   * @returns {number} Score de calidad combinado (0-1)
   */
  evaluateOCRQuality(text, confidence) {
    if (!text || text.length === 0) return 0;

    let score = confidence; // Empezar con la confianza base de Tesseract

    // Bonus por longitud de texto (m√°s texto generalmente = mejor extracci√≥n)
    const lengthBonus = Math.min(text.length / 500, 0.2); // Max 0.2 bonus
    score += lengthBonus;

    // Bonus por detectar palabras clave espec√≠ficas de EUROPIEL
    const europielKeywords = [
      'EUROPIEL', 'LASER', 'CENTER', 'SINERGIA', 'RECIBO', 'PAGO',
      'TRANSACCION', 'APROBADA', 'FOLIO', 'FECHA', 'CANTIDAD', 'CONCEPTO'
    ];
    const keywordsFound = europielKeywords.filter(keyword =>
      text.toUpperCase().includes(keyword)
    ).length;
    const keywordBonus = (keywordsFound / europielKeywords.length) * 0.15; // Max 0.15 bonus
    score += keywordBonus;

    // Bonus por detectar patrones t√≠picos (fechas, montos, folios)
    const patterns = [
      /\d{1,2}\/\d{1,2}\/\d{4}/, // Fechas DD/MM/YYYY
      /Q\d{2}-\d{4}/, // Folios tipo Q22-5237
      /\$[\d,]+\.?\d*/, // Montos en pesos
      /\d{4}\s*\d{4}\s*\d{4}\s*\d{4}/ // N√∫meros de tarjeta
    ];
    const patternsFound = patterns.filter(pattern => pattern.test(text)).length;
    const patternBonus = (patternsFound / patterns.length) * 0.1; // Max 0.1 bonus
    score += patternBonus;

    // Penalizaci√≥n por caracteres extra√±os o demasiados errores de OCR
    const strangeChars = (text.match(/[^a-zA-Z√°√©√≠√≥√∫√º√±√Å√â√ç√ì√ö√ú√ë0-9\s.,;:!?()$\-"'\/]/g) || []).length;
    const strangePenalty = Math.min(strangeChars / text.length * 2, 0.25); // Max 0.25 penalty
    score -= strangePenalty;

    // Penalizaci√≥n por texto muy fragmentado (muchos espacios o l√≠neas vac√≠as)
    const fragmentationRatio = (text.match(/\s{3,}|\n{2,}/g) || []).length / text.length * 100;
    const fragmentationPenalty = Math.min(fragmentationRatio, 0.15); // Max 0.15 penalty
    score -= fragmentationPenalty;

    // Bonus por estructura coherente (p√°rrafos, l√≠neas bien formadas)
    const lines = text.split('\n').filter(line => line.trim().length > 0);
    const avgLineLength = lines.length > 0 ? text.length / lines.length : 0;
    if (avgLineLength > 20 && avgLineLength < 100) { // Longitud de l√≠nea razonable
      score += 0.05;
    }

    return Math.max(0, Math.min(1, score)); // Asegurar que est√© entre 0 y 1
  }

  /**
   * Preprocesar imagen para mejorar calidad del OCR
   */
  async preprocessImage(imagePath) {
    try {
      console.log('ÔøΩ Iniciando preprocesamiento optimizado...');

      // USAR LAS NUEVAS FUNCIONALIDADES OPTIMIZADAS DE IMAGEPROCESSOR
      const processingOptions = {
        enableContrast: this.enhancementConfig?.enableContrast ?? true,
        enableOrientation: this.enhancementConfig?.enableOrientation ?? true,
        enableNoiseReduction: this.enhancementConfig?.enableNoiseReduction ?? true,
        keepIntermediateFiles: this.enhancementConfig?.keepIntermediateFiles ?? false
      };

      // Aplicar procesamiento completo optimizado
      const result = await ImageProcessor.optimizedFullProcessing(imagePath, processingOptions);

      if (result.error) {
        console.warn('‚ö†Ô∏è Error en procesamiento optimizado, usando imagen original:', result.error);
        return imagePath;
      }

      // Log de mejoras aplicadas
      console.log(`‚úÖ Procesamiento completado en ${result.totalTime}ms`);
      console.log(`üéØ Mejoras aplicadas: ${result.improvements.join(', ')}`);

      // Verificar que el archivo procesado existe
      try {
        await fs.access(result.finalPath);
        console.log(`üìÅ Imagen procesada guardada: ${path.basename(result.finalPath)}`);
        return result.finalPath;
      } catch (accessError) {
        console.warn('‚ö†Ô∏è Archivo procesado no accesible, usando original');
        return imagePath;
      }

    } catch (error) {
      console.error('‚ùå Error cr√≠tico en preprocesamiento:', error);
      return imagePath; // Fallback a imagen original
    }
  }

  // M√âTODO DE RESPALDO - Preprocesamiento legacy por si falla el optimizado
  async fallbackPreprocessImage(imagePath) {
    try {
      console.log('üîÑ Usando preprocesamiento de respaldo...');

      // PASO 1: Auto-rotaci√≥n usando OpenCV.js
      let rotationResult;
      try {
        console.log('üéØ Aplicando auto-rotaci√≥n con OpenCV...');
        rotationResult = await ImageProcessor.autoRotateImage(imagePath);

        if (rotationResult.rotated) {
          console.log(`‚úÖ Imagen rotada ${rotationResult.rotationApplied}¬∞ (Score: ${(rotationResult.orientationScore * 100).toFixed(1)}%)`);

          // Guardar imagen rotada temporalmente
          const rotatedPath = imagePath.replace(/\.[^/.]+$/, '_rotated.png');
          await fs.writeFile(rotatedPath, rotationResult.buffer);
          imagePath = rotatedPath; // Usar imagen rotada para siguiente paso
        } else {
          console.log('‚ÑπÔ∏è No se detect√≥ necesidad de rotaci√≥n');
        }
      } catch (rotationError) {
        console.warn('‚ö†Ô∏è Error en auto-rotaci√≥n, continuando sin rotar:', rotationError.message);
        rotationResult = { rotated: false, rotationApplied: 0, orientationScore: 0 };
      }

      // PASO 2: Preprocesamiento mejorado para documentos de calidad variable
      const outputPath = imagePath.replace(/\.[^/.]+$/, '_processed.png');

      // Obtener metadatos de la imagen para an√°lisis
      const metadata = await sharp(imagePath).metadata();
      console.log(`üìä Imagen original: ${metadata.width}x${metadata.height}, calidad estimada: ${metadata.density || 'desconocida'}`);

      // Preprocesamiento adaptativo basado en calidad detectada
      let sharpProcessor = sharp(imagePath)
        .greyscale() // Convertir a escala de grises
        .normalise({ lower: 1, upper: 99 }) // Normalizar contraste m√°s agresivo
        .modulate({
          brightness: 1.1, // Aumentar brillo ligeramente
          saturation: 0,   // Eliminar saturaci√≥n completamente
          hue: 0
        })
        .gamma(1.2) // Ajuste de gamma para mejor contraste
        .sharpen({
          sigma: 1.5,    // Sharpening m√°s agresivo
          flat: 1.5,
          jagged: 3
        });

      // Para im√°genes de baja resoluci√≥n, aplicar upscaling m√°s agresivo
      if (metadata.width < 1500 || metadata.height < 1500) {
        console.log('üìà Aplicando upscaling para imagen de baja resoluci√≥n...');
        sharpProcessor = sharpProcessor.resize({
          width: Math.max(3000, metadata.width * 2),
          height: Math.max(4000, metadata.height * 2),
          fit: 'inside',
          withoutEnlargement: false,
          kernel: sharp.kernel.lanczos3
        });
      } else {
        // Para im√°genes de buena resoluci√≥n, resize m√°s conservador
        sharpProcessor = sharpProcessor.resize({
          width: 3000,
          withoutEnlargement: true,
          kernel: sharp.kernel.lanczos3
        });
      }

      // Aplicar threshold adaptativo para binarizaci√≥n
      await sharpProcessor
        .threshold(120, { greyscale: false }) // Threshold m√°s bajo para capturar texto tenue
        .png({
          compressionLevel: 0,
          quality: 100,
          progressive: false
        })
        .toFile(outputPath);

      console.log(`üñºÔ∏è Imagen preprocesada con mejoras adaptativas: ${outputPath}`);

      // Retornar informaci√≥n del preprocesamiento
      return {
        path: outputPath,
        rotationApplied: rotationResult.rotated,
        rotationDegrees: rotationResult.rotationApplied,
        orientationScore: rotationResult.orientationScore
      };
    } catch (error) {
      console.error('‚ùå Error preprocesando imagen:', error);
      return {
        path: imagePath, // Usar imagen original si falla el preprocesamiento
        rotationApplied: false,
        rotationDegrees: 0,
        orientationScore: 0
      };
    }
  }

  /**
   * üéõÔ∏è CONFIGURAR MEJORAS DE PROCESAMIENTO
   * Permite habilitar/deshabilitar mejoras espec√≠ficas seg√∫n necesidad
   * @param {Object} config - Configuraci√≥n de mejoras
   * @returns {Object} Configuraci√≥n aplicada
   */
  configureImageEnhancements(config = {}) {
    const defaultConfig = {
      enableContrast: true,        // Normalizaci√≥n de contraste (recomendado)
      enableOrientation: true,     // Detecci√≥n de orientaci√≥n (recomendado)
      enableNoiseReduction: false, // Deshabilitado por defecto para velocidad
      keepIntermediateFiles: false, // Mantener archivos intermedios (solo para debug)
      fastMode: true               // ‚ö° FAST MODE ACTIVADO POR DEFECTO
    };

    this.enhancementConfig = { ...defaultConfig, ...config };

    // Ajustar configuraci√≥n para modo r√°pido
    if (this.enhancementConfig.fastMode) {
      this.enhancementConfig.enableNoiseReduction = false;
      console.log('‚ö° Modo r√°pido activado - reducci√≥n de ruido deshabilitada');
    }

    console.log('üéõÔ∏è Configuraci√≥n de mejoras aplicada:', this.enhancementConfig);
    return this.enhancementConfig;
  }

  /**
   * üìä OBTENER ESTAD√çSTICAS DE PROCESAMIENTO
   * Devuelve estad√≠sticas de las mejoras aplicadas
   * @returns {Object} Estad√≠sticas de rendimiento
   */
  getProcessingStats() {
    return {
      enhancementConfig: this.enhancementConfig || null,
      supportedFeatures: {
        contrastNormalization: '‚úÖ Normalizaci√≥n de contraste r√°pida (< 100ms)',
        orientationDetection: '‚úÖ Detecci√≥n de orientaci√≥n autom√°tica',
        noiseReduction: '‚úÖ Limpieza de ruido b√°sica',
        batchProcessing: '‚úÖ Procesamiento por lotes optimizado'
      },
      recommendations: {
        fastProcessing: 'Usar fastMode=true para lotes grandes',
        highAccuracy: 'Habilitar todas las mejoras para documentos cr√≠ticos',
        debugging: 'keepIntermediateFiles=true para an√°lisis detallado'
      }
    };
  }

  /**
   * Extraer bounding boxes de palabras y l√≠neas
   */
  extractBoundingBoxes(tesseractData) {
    const boundingBoxes = {
      words: [],
      lines: [],
      paragraphs: []
    };

    // Extraer bounding boxes de palabras
    tesseractData.words.forEach(word => {
      if (word.confidence > 30) { // Solo palabras con confianza > 30%
        boundingBoxes.words.push({
          text: word.text,
          confidence: word.confidence / 100,
          bbox: {
            x0: word.bbox.x0,
            y0: word.bbox.y0,
            x1: word.bbox.x1,
            y1: word.bbox.y1
          }
        });
      }
    });

    // Extraer bounding boxes de l√≠neas
    tesseractData.lines.forEach(line => {
      boundingBoxes.lines.push({
        text: line.text,
        confidence: line.confidence / 100,
        bbox: {
          x0: line.bbox.x0,
          y0: line.bbox.y0,
          x1: line.bbox.x1,
          y1: line.bbox.y1
        }
      });
    });

    // Extraer bounding boxes de p√°rrafos
    tesseractData.paragraphs.forEach(paragraph => {
      boundingBoxes.paragraphs.push({
        text: paragraph.text,
        confidence: paragraph.confidence / 100,
        bbox: {
          x0: paragraph.bbox.x0,
          y0: paragraph.bbox.y0,
          x1: paragraph.bbox.x1,
          y1: paragraph.bbox.y1
        }
      });
    });

    return boundingBoxes;
  }

  /**
   * Aplicar correcciones autom√°ticas basadas en patrones aprendidos
   */
  async applyMLCorrections(text, documentType = null) {
    try {
      console.log('üß† Aplicando correcciones de ML...');

      // Obtener patrones activos de la base de datos
      const patternsQuery = `
        SELECT original_pattern, corrected_pattern, accuracy_score, frequency
        FROM ocr_patterns
        WHERE is_active = true
        ${documentType ? 'AND $1 = ANY(document_types)' : ''}
        ORDER BY frequency DESC, accuracy_score DESC
        LIMIT 100
      `;

      const patterns = await pool.query(
        patternsQuery,
        documentType ? [documentType] : []
      );

      let correctedText = text;
      let appliedCorrections = [];

      // Aplicar cada patr√≥n
      for (const pattern of patterns.rows) {
        const regex = new RegExp(this.escapeRegex(pattern.original_pattern), 'gi');
        const matches = correctedText.match(regex);

        if (matches) {
          correctedText = correctedText.replace(regex, pattern.corrected_pattern);
          appliedCorrections.push({
            original: pattern.original_pattern,
            corrected: pattern.corrected_pattern,
            occurrences: matches.length,
            accuracy: pattern.accuracy_score
          });
        }
      }

      // Aplicar correcciones de contexto
      correctedText = await this.applyContextCorrections(correctedText);

      console.log(`‚úÖ ML aplic√≥ ${appliedCorrections.length} correcciones`);
      return {
        correctedText,
        appliedCorrections,
        improvementScore: this.calculateImprovementScore(text, correctedText)
      };

    } catch (error) {
      console.error('‚ùå Error aplicando correcciones ML:', error);
      return { correctedText: text, appliedCorrections: [], improvementScore: 0 };
    }
  }

  /**
   * Aplicar correcciones de contexto (n√∫meros, fechas, emails, etc.)
   */
  async applyContextCorrections(text) {
    let corrected = text;

    // Corregir n√∫meros comunes mal reconocidos
    const numberCorrections = {
      'O': '0', 'l': '1', 'I': '1', 'S': '5', 'G': '6', 'T': '7', 'B': '8', 'g': '9'
    };

    // Corregir fechas (formato DD/MM/YYYY o DD-MM-YYYY)
    corrected = corrected.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/g, (match, day, month, year) => {
      return `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
    });

    // Corregir emails
    corrected = corrected.replace(/(\w+)[\s\.](\w+)@(\w+)[\s\.](\w+)/g, '$1.$2@$3.$4');

    // Corregir n√∫meros de tel√©fono
    corrected = corrected.replace(/(\d{3})[\s\-]?(\d{3})[\s\-]?(\d{4})/g, '$1-$2-$3');

    return corrected;
  }

  /**
   * Guardar resultado OCR en base de datos
   */
  async saveOCRResult(documentId, ocrData, correctedText = null) {
    try {
      const query = `
        INSERT INTO ocr_results (
          document_id, raw_text, corrected_text, confidence_score,
          processing_time_ms, bounding_boxes, page_number
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING id
      `;

      const values = [
        documentId,
        ocrData.text || '',
        correctedText || ocrData.text || '',
        ocrData.confidence || 0,
        ocrData.processingTime || 0,
        JSON.stringify(ocrData.boundingBoxes || {}),
        1 // Por ahora solo una p√°gina
      ];

      const result = await pool.query(query, values);
      return { success: true, resultId: result.rows[0].id };

    } catch (error) {
      console.error('‚ùå Error guardando resultado OCR:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Procesar feedback del usuario para entrenar el modelo
   */
  async processFeedback(resultId, originalText, correctedText, correctionType = 'manual') {
    try {
      // Guardar datos de entrenamiento
      console.log('üîç Analizando feedback:');
      console.log('   Original:', originalText.substring(0, 50) + '...');
      console.log('   Corregido:', correctedText.substring(0, 50) + '...');

      const trainingQuery = `
        INSERT INTO ocr_training_data (
          result_id, original_text, corrected_text, correction_type,
          user_feedback, pattern_category
        ) VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
      `;

      const patternCategory = this.categorizePattern(originalText, correctedText);
      console.log('üìä Categor√≠a del patr√≥n:', patternCategory);

      const trainingResult = await pool.query(trainingQuery, [
        resultId, // Puede ser null
        originalText,
        correctedText,
        correctionType,
        'manual',
        patternCategory
      ]);

      // Actualizar o crear patr√≥n
      const patternResult = await this.updatePattern(originalText, correctedText, patternCategory);
      console.log('üíæ Resultado actualizaci√≥n patr√≥n:', patternResult);

      console.log(`‚úÖ Feedback procesado para resultado ${resultId}`);
      return { success: true, trainingId: trainingResult.rows[0].id };

    } catch (error) {
      console.error('‚ùå Error procesando feedback:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Actualizar patr√≥n en base de datos
   */
  async updatePattern(originalText, correctedText, category) {
    try {
      // Intentar actualizar patr√≥n existente
      const updateQuery = `
        UPDATE ocr_patterns
        SET frequency = frequency + 1,
            last_seen = CURRENT_TIMESTAMP,
            accuracy_score = LEAST(accuracy_score + 0.1, 1.0)
        WHERE original_pattern = $1 AND corrected_pattern = $2
        RETURNING id
      `;

      const updateResult = await pool.query(updateQuery, [originalText, correctedText]);

      if (updateResult.rows.length === 0) {
        // Crear nuevo patr√≥n
        const insertQuery = `
          INSERT INTO ocr_patterns (
            pattern_type, original_pattern, corrected_pattern,
            context_category, frequency, accuracy_score
          ) VALUES ($1, $2, $3, $4, 1, 0.5)
        `;

        await pool.query(insertQuery, [
          'user_correction',
          originalText,
          correctedText,
          category
        ]);
      }

      return { success: true };
    } catch (error) {
      console.error('‚ùå Error actualizando patr√≥n:', error);
      return { success: false, error: error.message };
    }
  }

  // M√©todos auxiliares
  escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  categorizePattern(original, corrected) {
    if (/\d/.test(original) && /\d/.test(corrected)) return 'number';
    if (/@/.test(corrected)) return 'email';
    if (/\d{2}\/\d{2}\/\d{4}/.test(corrected)) return 'date';
    if (original.length === 1 && corrected.length === 1) return 'character';
    if (original.split(' ').length === corrected.split(' ').length) return 'word';
    return 'text';
  }

  calculateImprovementScore(original, corrected) {
    if (original === corrected) return 0;
    const editDistance = this.levenshteinDistance(original, corrected);
    return Math.max(0, 1 - (editDistance / Math.max(original.length, corrected.length)));
  }

  levenshteinDistance(str1, str2) {
    const track = Array(str2.length + 1).fill(null).map(() =>
      Array(str1.length + 1).fill(null));

    for (let i = 0; i <= str1.length; i += 1) {
      track[0][i] = i;
    }
    for (let j = 0; j <= str2.length; j += 1) {
      track[j][0] = j;
    }
    for (let j = 1; j <= str2.length; j += 1) {
      for (let i = 1; i <= str1.length; i += 1) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        track[j][i] = Math.min(
          track[j][i - 1] + 1, // deletion
          track[j - 1][i] + 1, // insertion
          track[j - 1][i - 1] + indicator // substitution
        );
      }
    }
    return track[str2.length][str1.length];
  }

  /**
   * Obtiene estad√≠sticas del clasificador de documentos
   */
  getClassifierStats() {
    return this.classifier.getStats();
  }

  /**
   * Permite aprender de una clasificaci√≥n manual
   */
  async learnFromManualClassification(extractedText, correctType, additionalFields = {}) {
    return await this.classifier.learnFromCorrection(extractedText, correctType, additionalFields);
  }
}

export default new OCRService();
